[{"id":"4a207b7e885fdbcca8129599135e5f2e","title":"MySQL基础","content":"\nMySQL基础数据库概论数据管理演变\n\n人工档案管理\n文件系统管理\n数据库管理\n\n\n数据库管理系统\n\n层次数据库\n网状型数据库\n关系型数据库\n网格型数据库\n对象型数据库\n非关系型数据库\n\n\n关系型数据库1234数据库是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合.在数据库中的数据我们可以用二维表格的形式理解,例如表格中一列的标题我们称之为字段表格中一行数据我们称之为一条记录\n\n\n\n\nid\naccount\npassword\nnickname\nuuid\n\n\n\n1\nroot\nroot\n超级管理员\n2e6342dd-c475-410f-9948-e4cc1948ef0f\n\n\n2\nadmin\nadmin\nguanli\ne30e8060-9320-4b72-8722-10328348a272\n\n\n3\nphoenix\n123456\n李昊哲\n3ddc2b0e-fdba-4f61-b0a8-2585ffdce940\n\n\n1234数据库由3部分组成数据库：用于存储数据数据库管理系统：用户管理数据库的软件数据库应用程序：为了提高数据库系统的管理能力使用的数据库管理的补充\n\n\n12345678910111213141516171819对数据库进行查询、修改操作的语言我们称之为SQL结构化查询语言(Structured Query Language)简称SQL(发音：/ˈes kjuː ˈel/ &quot;S-Q-L&quot;)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的后缀名。+标准：SQL-92、SQL-99、SQL-2003非标准：方言常用关系型数据库Oracle、MySQL、SQLServer、...对象型数据库PostgresQL、...常用的非关系数据库（在中国）Redis、MongoDB、HBase、..按照SQL-92标准SQL包含4部分1、数据库定义语言(DDL)：create、drop、alter、...2、数据库操作语言(DML)：insert、update、delete、...3、数据库查询语言(DQL)：select4、数据库控制语言(DCL)：grant、revoke、.5、数据库事务控制语言(TCL)：commit、rollback\n\n安装\n在线安装\n安装包\n绿色版\n集成环境\n编译安装\n\n数据库常用操作连接数据库\nmysql\n-h 服务器IP\n-u 账户\n-p 密码\n\n1mysql -h localhost -uroot -p\n\n1234567891011Welcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 14Server version: 9.0.1 MySQL Community Server - GPLCopyright (c) 2000, 2024, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.\n\n显示目前已有数据库1show databases;\n\n1234567891011mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)\n\n显示当前使用的数据库12345678mysql&gt; select database();+------------+| database() |+------------+| NULL       |+------------+1 row in set (0.00 sec)\n\n创建数据库12345# 创建数据库 格式：create database 数据库名称;create database `chap01`;# 显示已存在的数据库 检查数据库创建是否成功show databases;\n\n查看数据库创建详细过程12345678mysql&gt; show create database `chap01`;+----------+----------------------------------------------------------------------------------------------------------------------------------+| Database | Create Database                                                                                                                  |+----------+----------------------------------------------------------------------------------------------------------------------------------+| chap01   | CREATE DATABASE `chap01` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */ |+----------+----------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)\n\n创建数据库同时指定字符集12345# 创建数据库并指定字符集 推荐字符集使用 utf8 或者  utf8mb4create database `chap001` default character set gbk;show databases;show create database `chap001`;\n\n删除数据库1234# 删除数据库 drop database 数据库名称drop database `chap001`;# 显示已存在的数据库 检查数据库删除是否成功show databases;\n\n切换数据库\n使用哪一个数据库\n\n12345# 切换数据库 使用哪个数据库use chap01;#  显示当前使用的数据库 检查数据库切换是否成功select database();\n\n123456789101112131415161718mysql&gt; select database();+------------+| database() |+------------+| NULL       |+------------+1 row in set (0.00 sec)mysql&gt; use chap01;Database changedmysql&gt; select database();+------------+| database() |+------------+| chap01     |+------------+1 row in set (0.00 sec)\n\n数据表常用操作\n创建基本数据表1234567891011# 创建数据库create databae chap01;# 使用刚刚创建的数据库use chap01;# 创建数据表 格式 create table 表名称# [HY000][4028] A table must have at least one visible column.# create table `tb_user`;# 基本格式 create table 表名称 (字段1 数据类型,字段2 数据类型,字段...);create table `tb_user` (`user_id` int,`user_name` varchar(50));\n\n查看数据表创建详细过程1show create table `tb_user`;\n\n\n根据数据表创建详细过程 引申出 创建数据表的格式\n创建数据表的同时 指定使用的引擎和字符集\n\n1234create table `tb_user` (    `user_id` int,    `user_name` varchar(50)) engine=innodb default charset=utf8mb4;\n\n描述数据表结构12describe `tb_user`;desc `tb_user`;\n\n显示当前数据库所有数据表1show tables;\n\n删除数据表1drop table `tb_user`;\n\n存储引擎\n数据库存储引擎是数据库地产软件组织\n\n\nMySQL 提供了多给不同的存储引擎，包括事务安全型和非事务安全型\n\n1show engines;\n\n\n数据类型\n\n数值型 整数、浮点数和定点数\n日期与时间\n字符串\n布尔型\n\n\n整数型\n\n\n数据类型\n说明\n存储\n有符号范围\n无符号范围\n\n\n\ntinyint\n很小的整数\n1字节\n-128~127\n0~255\n\n\nsmallint\n小的整数\n2字节\n-32768~32767\n0~65535\n\n\nmediumint\n中等大小的整数\n3字节\n-8388608~8388607\n0~16777215\n\n\nint(integer)\n普通大小的整数\n4字节\n-2147483648~2147483647\n0~4294967295\n\n\nbigint\n大整数\n8字节\n-9223372036854775808~9223372036854775807\n0~18446744073709551615\n\n\n浮点型\n\n\n数据类型\n说明\n存储\n有符号范围\n无符号范围\n\n\n\nfloat\n单精度浮点数\n4个字\n\n\n\n\ndouble\n双精度浮点数\n8个字节\n\n\n\n\n定点型\n\n\n数据类型\n说明\n存储\n有符号范围\n无符号范围\n\n\n\ndecimal(M,D)\n严格定点数\nM+2个字节\n\n\n\n\n日期与时间\n\n\n数据类型\n日期格式\n存储\n日期范围\n\n\n\nyear\nYYYY\n1字节\n1901~2155\n\n\ndate\nYYYY-MM-DD\n3字节\n1000-01-01~9999-12-31\n\n\ntime\nHH:MM:SS\n3字节\n-838:59:59~838:59:59\n\n\ndatetime\nYYYY-MM-DD HH:MM:SS\n8字节\n1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n\n\ntimestamp\nYYYY-MM-DD HH:MM:SS\n4字节\n1970-01-01 00:00:00 UTC ~ 2038-01-19 03:14:07 UTC\n\n\n字符串\n文本字符串\n\n\n\n数据类型\n说明\n存储\n\n\n\nchar(M)\n固定长度\nM字节，1 &lt;&#x3D;  M &lt;&#x3D;255\n\n\nvarchar(M)\n非固定长度 可变长\nL字节，L &lt;&#x3D; M 和1 &lt;&#x3D;  M &lt;&#x3D;255\n\n\ntinytext\n非常小的文本\n2^8\n\n\ntext\n小文本\n2^16\n\n\nmediumtext\n中等大小的文本\n2^24\n\n\nlongtext\n大的文本\n2^32\n\n\n\n二进制字符串\n\n\n\n数据类型\n说明\n存储\n\n\n\nbit\n\n\n\n\nbinary\n\n\n\n\nvarbinary\n\n\n\n\ntinyblob\n\n\n\n\nmediumblob\n\n\n\n\nlongblob\n\n\n\n\n\n\nDML准备1234create table tb_user (    user_id int,    user_name varchar(50)) engine=innodb default charset=utf8mb4;\n\ninsert\n格式 插入一条数据 insert into 数据表名 (字段1名,字段2名,…) value (字段1值,字段2值,…)\n格式 插入一条数据 为所有字段赋值 insert into 数据表名 value (字段1值,字段2值,…)\n\n12insert into tb_user (user_id,user_name) value (1,&#x27;user01&#x27;);insert into tb_user value (2,&#x27;user02&#x27;);\n\n\n格式 插入多条数据 insert into 数据表名 (字段1名,字段2名,…) values (字段1值,字段2值,…),(字段1值,字段2值,…)\n\n1insert into tb_user values (3,&#x27;user03&#x27;),(4,&#x27;user04&#x27;);\n\n\n查询数据表中的数据\n\n1select * from tb_user;\n\nupdate\nupdate 数据表名 set 字段1名 &#x3D; 值,字段2名 &#x3D; 值,… where 筛选字段(值必须能够帝国为到当前行)\n\n1234# update tb_user set user_name = &#x27;李昊哲&#x27;;update tb_user set user_name = &#x27;李昊哲&#x27; where user_id = 3;select * from tb_user;\n\ndelete truncate\n 格式 delete from 数据表名 where 筛选字段(值必须能够帝国为到当前行)\n\n1234# delete from tb_user;delete from tb_user where user_id = 3;select * from tb_user;\n\n\n清空数据表\n\n12# delete from tb_user;truncate tb_user;\n\n\n重点面试题 重点中的重点 必问delete 与 truncate 区别一般人的回答 delete 仅仅是删除数据效率比较低 truncate 相对于删除表后在重新建表 效率比较高高手的回答 delete 效率比较低 为每行数据打一个标记 水位线线不变高手的回答 truncate 效率比较高 相对于删除表后在重新建表 重置水位线\nupdate 与 delete 哪个速度更快update &#x3D; delete + insert\n\n约束\n\n非空约束\n\n默认约束\n\n唯一约束\n\n检查约束\n\n主键约束\n\n外键约束\n\n\n\n非空约束1234567create table user01 (    id int comment &#x27;用户编号&#x27;,    account varchar(50) not null comment &#x27;用户账号&#x27;,    password varchar(200) not null comment &#x27;用户密码&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;);\n\n123456789101112mysql&gt; describe user01;+-----------+--------------+------+-----+---------+-------+| Field     | Type         | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+-------+| id        | int unsigned | YES  |     | NULL    |       || account   | varchar(50)  | NO   |     | NULL    |       || password  | varchar(200) | NO   |     | NULL    |       || real_name | varchar(50)  | YES  |     | NULL    |       |+-----------+--------------+------+-----+---------+-------+4 rows in set (0.00 sec)\n\n123456insert into user01 value (1,&#x27;admin01&#x27;,&#x27;pass01&#x27;,&#x27;user01&#x27;);insert into user01 (id, account, password) value (2,&#x27;admin02&#x27;,&#x27;pass02&#x27;);select * from user01;# [HY000][1364] Field &#x27;account&#x27; doesn&#x27;t have a default valueinsert into user01 (id) value (2);\n\n默认约束123456create table user02 (    id int unsigned comment &#x27;用户编号&#x27;,    account varchar(50) not null comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;);\n\n1234567891011mysql&gt; describe  user02;+-----------+--------------+------+-----+---------+-------+| Field     | Type         | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+-------+| id        | int unsigned | YES  |     | NULL    |       || account   | varchar(50)  | NO   |     | NULL    |       || password  | varchar(200) | NO   |     | 123456  |       || real_name | varchar(50)  | YES  |     | NULL    |       |+-----------+--------------+------+-----+---------+-------+4 rows in set (0.01 sec)\n\n12345insert into user02 value (1,&#x27;admin01&#x27;,&#x27;pass01&#x27;,&#x27;user01&#x27;);insert into user02 (id, account, password) value (2,&#x27;admin02&#x27;,&#x27;pass02&#x27;);insert into user02 (id, account) value (3,&#x27;admin03&#x27;);select * from user02;\n\n唯一性约束\n注意：值虽然不能重复但是可以为空\n\n12345678910111213141516create table user03 (    id int unsigned comment &#x27;用户编号&#x27;,    account varchar(50) not null comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    id_card varchar(18) unique comment &#x27;身份证&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;);# 或者create table user03 (    id int unsigned comment &#x27;用户编号&#x27;,    account varchar(50) not null comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    id_card varchar(18) comment &#x27;身份证&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;,    unique key id_card (id_card));\n\n123456789101112mysql&gt; describe user03;+-----------+--------------+------+-----+---------+-------+| Field     | Type         | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+-------+| id        | int unsigned | YES  |     | NULL    |       || account   | varchar(50)  | NO   |     | NULL    |       || password  | varchar(200) | NO   |     | 123456  |       || id_card   | varchar(18)  | YES  | UNI | NULL    |       || real_name | varchar(50)  | YES  |     | NULL    |       |+-----------+--------------+------+-----+---------+-------+5 rows in set (0.00 sec)\n\n123456insert into user03  value (1,&#x27;admin01&#x27;,&#x27;pass01&#x27;,&#x27;220422&#x27;,&#x27;user01&#x27;);# [23000][1062] Duplicate entry &#x27;220422&#x27; for key &#x27;user03.id_card&#x27;insert into user03  value (2,&#x27;admin02&#x27;,&#x27;pass02&#x27;,&#x27;220422&#x27;,&#x27;user02&#x27;);insert into user03 (id, account, password, real_name) value (3,&#x27;admin03&#x27;,&#x27;pass03&#x27;,&#x27;user03&#x27;);insert into user03 (id, account, password, real_name) value (4,&#x27;admin04&#x27;,&#x27;pass04&#x27;,&#x27;user04&#x27;);select * from user03;\n\n检查性约束\n注意：值虽然必须符合检查规则但是可以为空\n\n12345678create table user04(    id int unsigned comment &#x27;用户编号&#x27;,    account varchar(50) not null comment &#x27;用户账号&#x27;,    password varchar(50) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    id_card char(18) unique comment &#x27;身份证&#x27;,    age int unsigned check (age &gt;= 18)  comment &#x27;用户年龄 年龄在18岁以上包含18岁&#x27;,    real_name varchar(50) comment &#x27;用户密码&#x27;);\n\n12345678910111213mysql&gt; describe user04;+-----------+--------------+------+-----+---------+-------+| Field     | Type         | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+-------+| id        | int unsigned | YES  |     | NULL    |       || account   | varchar(50)  | NO   |     | NULL    |       || password  | varchar(200) | NO   |     | 123456  |       || id_card   | varchar(18)  | YES  | UNI | NULL    |       || age       | int unsigned | YES  |     | NULL    |       || real_name | varchar(50)  | YES  |     | NULL    |       |+-----------+--------------+------+-----+---------+-------+6 rows in set (0.00 sec)\n\n123456describe user04;insert into user04 (id,account,age) value (1,&#x27;admin01&#x27;, 18);# [HY000][3819] Check constraint &#x27;user04_chk_1&#x27; is violated.insert into user04 (id,account,age) value (2,&#x27;admin02&#x27;, 17);insert into user04 (id,account) value (3,&#x27;admin03&#x27;);select * from user04;\n\n主键约束\n值不能为空且唯一约束\n主键约束 约等于 非空约束 + 唯一性约束\n\n123456create table user050 (    id int unsigned comment &#x27;用户编号&#x27;,    account varchar(50) not null unique comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;);\n\n12345678910mysql&gt; describe user050;+-----------+--------------+------+-----+---------+-------+| Field     | Type         | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+-------+| id        | int unsigned | YES  |     | NULL    |       || account   | varchar(50)  | NO   | PRI | NULL    |       || password  | varchar(200) | NO   |     | 123456  |       || real_name | varchar(50)  | YES  |     | NULL    |       |+-----------+--------------+------+-----+---------+-------+4 rows in set (0.00 sec)\n\n1234567891011121314mysql&gt; show create table user050;+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table   | Create Table                                                                                                                                                                                                                                                                                                                                                                                |+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| user050 | CREATE TABLE `user050` (  `id` int unsigned DEFAULT NULL COMMENT &#x27;用户编号&#x27;,  `account` varchar(50) NOT NULL COMMENT &#x27;用户账号&#x27;,  `password` varchar(200) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;用户密码&#x27;,  `real_name` varchar(50) DEFAULT NULL COMMENT &#x27;用户姓名&#x27;,  UNIQUE KEY `account` (`account`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci                 |+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)\n\n单主键约束1234567891011121314create table user051 (    id int unsigned primary key comment &#x27;用户编号&#x27;,    account varchar(50) not null unique comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;);# 或者create table user051 (    id int unsigned comment &#x27;用户编号&#x27;,    account varchar(50) not null unique comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;,    primary key (id));\n\n12345678910mysql&gt; describe user051;+-----------+--------------+------+-----+---------+-------+| Field     | Type         | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+-------+| id        | int unsigned | NO   | PRI | NULL    |       || account   | varchar(50)  | NO   | UNI | NULL    |       || password  | varchar(200) | NO   |     | 123456  |       || real_name | varchar(50)  | YES  |     | NULL    |       |+-----------+--------------+------+-----+---------+-------+4 rows in set (0.00 sec)\n\n123456789101112131415mysql&gt; show create table user051;+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table   | Create Table                                                                                                                                                                                                                                                                                                                                                                                                  |+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| user051 | CREATE TABLE `user051` (  `id` int unsigned NOT NULL COMMENT &#x27;用户编号&#x27;,  `account` varchar(50) NOT NULL COMMENT &#x27;用户账号&#x27;,  `password` varchar(200) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;用户密码&#x27;,  `real_name` varchar(50) DEFAULT NULL COMMENT &#x27;用户姓名&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `account` (`account`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci                 |+---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)\n\n12345678insert into user051 value (1,&#x27;admin01&#x27;,&#x27;pass01&#x27;,&#x27;user01&#x27;);# [23000][1062] Duplicate entry &#x27;1&#x27; for key &#x27;user051.PRIMARY&#x27;insert into user051 value (1,&#x27;admin02&#x27;,&#x27;pass02&#x27;,&#x27;user02&#x27;);# [HY000][1364] Field &#x27;id&#x27; doesn&#x27;t have a default valueinsert into user051 (account, password, real_name) value (&#x27;admin03&#x27;,&#x27;pass03&#x27;,&#x27;user03&#x27;);select * from user051;\n\n主键自增长\nauto_increment\n\n1234567create table user052 (    id int unsigned auto_increment comment &#x27;用户编号&#x27;,    account varchar(50) not null unique comment &#x27;用户账号&#x27;,    password varchar(200) not null default &#x27;123456&#x27; comment &#x27;用户密码&#x27;,    real_name varchar(50) comment &#x27;用户姓名&#x27;,    primary key (id));\n\n1234567891011mysql&gt; describe user052;+-----------+--------------+------+-----+---------+----------------+| Field     | Type         | Null | Key | Default | Extra          |+-----------+--------------+------+-----+---------+----------------+| id        | int unsigned | NO   | PRI | NULL    | auto_increment || account   | varchar(50)  | NO   | UNI | NULL    |                || password  | varchar(200) | NO   |     | 123456  |                || real_name | varchar(50)  | YES  |     | NULL    |                |+-----------+--------------+------+-----+---------+----------------+4 rows in set (0.00 sec)\n\n12insert into user052 (account, real_name) values (&#x27;admin01&#x27;,&#x27;user01&#x27;),(&#x27;admin02&#x27;,&#x27;user02&#x27;),(&#x27;admin03&#x27;,&#x27;user03&#x27;);select * from user052;\n\n联合主键12345678create table tb_order (    order_id int comment &#x27;订单号&#x27;,    item_id int comment &#x27;流水号&#x27;,    commodity_id int comment &#x27;商品编号&#x27;,    quantity int comment &#x27;购买数量&#x27;,    price int comment &#x27;单价&#x27;,    primary key (order_id,item_id));\n\n123456789101112mysql&gt; describe tb_order;+--------------+------+------+-----+---------+-------+| Field        | Type | Null | Key | Default | Extra |+--------------+------+------+-----+---------+-------+| order_id     | int  | NO   | PRI | NULL    |       || item_id      | int  | NO   | PRI | NULL    |       || commodity_id | int  | YES  |     | NULL    |       || quantity     | int  | YES  |     | NULL    |       || price        | int  | YES  |     | NULL    |       |+--------------+------+------+-----+---------+-------+5 rows in set (0.00 sec)\n\n12insert into tb_order values (10000,1,1001,1,10),(10000,2,1002,2,20),(10000,3,1003,3,003),(10001,1,1001,1,10),(10001,2,1002,2,20),(10001,3,1003,3,003);select * from  tb_order;\n\n外键约束1234567891011121314151617# 创建主表create table course (    c_id int auto_increment comment &#x27;专业编号&#x27;,    c_name varchar(20) comment &#x27;专业名称&#x27;,    primary key (c_id));insert into course (c_name) values (&#x27;大数据&#x27;),(&#x27;人工智能&#x27;);select * from course;# 创建从表create table student (    stu_id int auto_increment comment &#x27;学生编号&#x27;,    stu_name varchar(20) comment &#x27;学生姓名&#x27;,    c_id int comment &#x27;专业名称&#x27;,    primary key (stu_id),    constraint fk_course_student foreign key (c_id) references course (c_id));\n\n12345678910mysql&gt; describe student;+----------+-------------+------+-----+---------+----------------+| Field    | Type        | Null | Key | Default | Extra          |+----------+-------------+------+-----+---------+----------------+| stu_id   | int         | NO   | PRI | NULL    | auto_increment || stu_name | varchar(20) | YES  |     | NULL    |                || c_id     | int         | YES  | MUL | NULL    |                |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec)\n\n123insert into student (stu_name, c_id) values (&#x27;张三&#x27;,1),(&#x27;李四&#x27;,2),(&#x27;王五&#x27;,1),(&#x27;赵六&#x27;,2);select * from student;\n\n12# [23000][1452] Cannot add or update a child row: a foreign key constraint fails (`chap01`.`student`, CONSTRAINT `fk_course_student` FOREIGN KEY (`c_id`) REFERENCES `course` (`c_id`))insert into student (stu_name, c_id) values (&#x27;显眼包&#x27;,3);\n\n12# [23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`chap01`.`student`, CONSTRAINT `fk_course_student` FOREIGN KEY (`c_id`) REFERENCES `course` (`c_id`))delete from course where c_id = 2;\n\n12345678# [23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`chap01`.`student`, CONSTRAINT `fk_course_student` FOREIGN KEY (`c_id`) REFERENCES `course` (`c_id`))delete from course where c_id = 2;# 删除主表中被用于的数据 解决方案# 1、如果子表中存在匹配的记录 删除从表外键# 2、如果子表中存在匹配的记录 将从表数据级联删除# 3、如果子表中存在匹配的记录 将子表的中的外键字段数据设置为null# 4、如果子表中存在匹配的记录在不允许主表进行 update 和 delete 操作\n\n1drop  table student;\n\ncascade123456789101112# cascade 级联删除 当主表发生 update | delete 时，从表 同步 update | deletedrop table student;create table student (    stu_id int auto_increment comment &#x27;学生编号&#x27;,    stu_name varchar(20) comment &#x27;学生姓名&#x27;,    c_id int comment &#x27;专业名称&#x27;,    primary key (stu_id),    constraint fk_course_student foreign key (c_id) references course (c_id) on delete cascade on update cascade);insert into student (stu_name, c_id) values (&#x27;张三&#x27;,1),(&#x27;李四&#x27;,2),(&#x27;王五&#x27;,1),(&#x27;赵六&#x27;,2);select * from student;\n\n123update course set c_id = 3 where c_id = 2;select * from course;select * from student;\n\n123delete from course where c_id = 3;select * from course;select * from student;\n\nno action123456789101112131415161718# no action 当从表中有主表中匹配的记录 则不运行主表进行 update | delete 操作drop  table student;drop  table course;create table course (    c_id int auto_increment comment &#x27;专业编号&#x27;,    c_name varchar(20) comment &#x27;专业名称&#x27;,    primary key (c_id));insert into course (c_name) values (&#x27;大数据&#x27;),(&#x27;人工智能&#x27;);create table student (    stu_id int auto_increment comment &#x27;学生编号&#x27;,    stu_name varchar(20) comment &#x27;学生姓名&#x27;,    c_id int comment &#x27;专业名称&#x27;,    primary key (stu_id),    constraint fk_course_student foreign key (c_id) references course (c_id) on delete no action on update no action);insert into student (stu_name, c_id) values (&#x27;张三&#x27;,1),(&#x27;李四&#x27;,2),(&#x27;王五&#x27;,1),(&#x27;赵六&#x27;,2);select * from student;\n\n12# [23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`chap01`.`student`, CONSTRAINT `fk_course_student` FOREIGN KEY (`c_id`) REFERENCES `course` (`c_id`))update course set c_id = 3 where c_id = 2;\n\n12# [23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`chap01`.`student`, CONSTRAINT `fk_course_student` FOREIGN KEY (`c_id`) REFERENCES `course` (`c_id`))delete from course where c_id = 2;\n\nrestrict\nrestrict 同 no action ,都是立即检查外键约束\nMySQL 默认使用方案\n\nset null12345678910111213141516171819# 当主表 update | delete 时，从表匹配的记录字段 设置为 null 注意 外键不能设置 not nulldrop table student;drop table course;create table course (    c_id int auto_increment comment &#x27;专业编号&#x27;,    c_name varchar(20) comment &#x27;专业名称&#x27;,    primary key (c_id));insert into course (c_name) values (&#x27;大数据&#x27;),(&#x27;人工智能&#x27;);create table student (    stu_id int auto_increment comment &#x27;学生编号&#x27;,    stu_name varchar(20) comment &#x27;学生姓名&#x27;,    c_id int comment &#x27;专业名称&#x27;,    primary key (stu_id),    constraint fk_course_student foreign key (c_id) references course (c_id) on delete set null on update  set null);insert into student (stu_name, c_id) values (&#x27;张三&#x27;,1),(&#x27;李四&#x27;,2),(&#x27;王五&#x27;,1),(&#x27;赵六&#x27;,2);select * from student;\n\n123update course set c_id = 3 where c_id = 2;select * from course;select * from student;\n\n123delete from course where c_id = 1;select * from course;select * from student;\n\ndefault\ndefault 主表有变更时, 从表将外键列设置成一个默认的值但Innodb不能识别\n\n总结：\n主表更新从表同步，主表删除从表set null\n\n1234567891011121314151617drop table student;drop table course;create table course (    c_id int auto_increment comment &#x27;专业编号&#x27;,    c_name varchar(20) comment &#x27;专业名称&#x27;,    primary key (c_id));insert into course (c_name) values (&#x27;大数据&#x27;),(&#x27;人工智能&#x27;);create table student (    stu_id int auto_increment comment &#x27;学生编号&#x27;,    stu_name varchar(20) comment &#x27;学生姓名&#x27;,    c_id int comment &#x27;专业名称&#x27;,    primary key (stu_id),    constraint fk_course_student foreign key (c_id) references course (c_id) on delete set null on update cascade);insert into student (stu_name, c_id) values (&#x27;张三&#x27;,1),(&#x27;李四&#x27;,2),(&#x27;王五&#x27;,1),(&#x27;赵六&#x27;,2);select * from student;\n\n修改表修改表名称\n格式 alter table 旧表名称 rename to 新表名称\n\n1alter table tb_user rename to  user;\n\n1show tables;\n\n修改字段数据类型\n格式 alter table 表名称 modify  字段名称 新的数据类型\n\n1desc user;\n\n1alter table user modify user_name char(20);\n\n1desc user;\n\n修改字段数据约束\n格式 alter table 表名称 modify  字段名称 新数据类型 新约束\n\n1desc user;\n\n1alter table user modify user_name varchar(50) not null comment &#x27;姓名&#x27;;\n\n1desc user;\n\n修改字段名称\n格式 alter table 表名称 change  旧字段名称 新字段名称 新数据类型 新约束\n\n1desc user;\n\n1alter table user change user_name name char(20) null comment &#x27;姓名&#x27;;\n\n1desc user;\n\n添加字段\n格式 alter table 表名称 add 字段名称 数据类型 约束\n\n1desc user;\n\n123alter table user add gender enum(&#x27;F&#x27;,&#x27;M&#x27;) default &#x27;M&#x27; comment &#x27;性别 F代表女 M代表男 默认值M&#x27;;alter table user add date_of_birth date comment &#x27;出生日期&#x27; first;alter table user add id_card char(18) comment &#x27;身份证&#x27; after user_id;\n\n1desc user;\n\n删除字段\n格式 alter table 表名称 drop 字段名称\n\n1desc user;\n\n1alter table user drop date_of_birth;\n\n1desc user;\n\n调整字段位置\n格式 alter table 表名称 modify 字段名称 数据类型 约束 位置\n\n1desc user;\n\n12alter table user modify id_card char(18) not null comment &#x27;身份证&#x27;  first;alter table user modify user_id int not null comment &#x27;用户编号&#x27; after name;\n\n1desc user;\n\n修改存储引擎\n格式 alter table 表名称 engine &#x3D; 引擎名称\n\n1show  create table user;\n\n1alter table user engine = myisam;\n\n1show  create table user;\n\n修改字符集\n格式 alter table 表名称 character set  字符集名称\n\n1show  create table user;\n\n1alter table user character set gbk;\n\n1show  create table user;\n\n数据备份与还原数据备份\n使用 mysqldump\n格式：msyqldump 需要备份的数据库名称 -h 服务器地址 -u 账号 -p · 备份文件存储路径\n\n1234C:\\Users\\Administrator&gt;mysqldump chap01 -h localhost  -uroot -p &gt; d:\\chap01.sqlEnter password: ******C:\\Users\\Administrator&gt;\n\n数据还原\n\n使用 mysql 格式  mysql 需要被还原的库 -h 服务器地址 -u 账号 -p &lt; sql文件存储路径\n\n使用 source 格式  source  sql文件存储路径 \n注意：source 需要在mysql命令行下在需要被环境的数据库执行\n\n\n\n1234C:\\Users\\Administrator&gt;mysql chap01 -h localhost -uroot -p &lt; d:\\chap01.sqlEnter password: ******C:\\Users\\Administrator&gt;\n\n123456789101112131415161718C:\\Users\\Administrator&gt;mysql -h localhost -uroot -pEnter password: ******Welcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 32Server version: 9.0.1 MySQL Community Server - GPLCopyright (c) 2000, 2024, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt; use chap01;Database changedmysql&gt; source d:/chap01.sql;mysql&gt;\n\n\n注意：windows 路劲分隔符\nd:&#x2F;chap01.sql;\nd:\\\\chap01.sql;\n\n数据库查询语言 DQL\n准备数据123456789101112131415C:\\Users\\Administrator&gt; mysql -uroot -pEnter password: ******Welcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 20Server version: 8.0.34 MySQL Community Server - GPLCopyright (c) 2000, 2023, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt;\n\n1create database chap02;\n\n1use chap02;\n\n1source d:/chap02_data.sql;\n\n单表查询查询所有1select * from fruit;\n\n按字段查询1select f_name,f_price from fruit;\n\n12345678910111213141516171819202122232425262728293031# 2.2.3.1 查询香蕉的价格select f_name,f_price from fruit where f_name = &#x27;banana&#x27;;# 2.2.3.2 查询价格为10.30的水果select f_name,f_price from fruit where f_price = 10.30;# 2.2.3.4 查询价格 高于5.2 低于10.30 的水果select f_name,f_price from fruit where f_price &gt; 5.2 &amp;&amp; f_price &lt; 10.30;select f_name,f_price from fruit where f_price &gt; 5.2 and f_price &lt; 10.30;select f_name,f_price from fruit where f_price &gt;= 5.2 &amp;&amp; f_price &lt;= 10.30;select f_name,f_price from fruit where f_price &gt;= 5.2 and f_price &lt;= 10.30;# 2.2.3.5 查询价格 高于5.2 低于10.30 的水果# select f_name,f_price from fruit where f_price &gt;= 5.2 and f_price &lt;= 10.30;select f_name,f_price from fruit where f_price between 5.2 and 10.30;# 2.2.3.6 查询供应商 s_id 为 101 和 102 供应的水果select s_id,f_name,f_price from fruit where s_id = 101 || s_id = 102;select s_id,f_name,f_price from fruit where s_id = 101 or s_id = 102;# 查询价格在 5.2 与 10.2 之间 供应商 s_id 为 101 和 102 供应的水果select s_id,f_name,f_price    from        fruit    where        (f_price between 5.2 and 10.30)        and        (s_id = 101 or s_id = 102);select s_id,f_name,f_price    from        fruit    where        (s_id = 101 or s_id = 102)        and        (f_price between 5.2 and 10.30);\n\nin 查询123456# 2.2.4.1 查询供应商 s_id 为 101 和 102 供应的水果select s_id,f_name,f_price from fruit where s_id = 101 or s_id = 102;select s_id,f_name,f_price from fruit where s_id in ( 101 , 102);# 2.2.4.2 查询供应商 s_id 不是 101 和 102 供应的水果select s_id,f_name,f_price from fruit where s_id != 101 and s_id != 102;select s_id,f_name,f_price from fruit where s_id not in ( 101 , 102);\n\nnull 查询1234# 2.2.5.1 # 查询没有绑定邮箱的消费者select * from customer where c_email is null;# 2.2.5.2 # 查询没有绑定邮箱的消费者select * from customer where c_email is not null;\n\n模糊查询12345678910# 2.2.6.1 查询所有名称 b 开头的水果# % 代表零个或多个字符select * from fruit where f_name like &#x27;b%&#x27;;# 2.2.6.2 查询所有名称 含有 g 的水果select * from fruit where f_name like &#x27;%g%&#x27;;# 2.2.6.3 查询所有名称 b开头 y结尾 的水果select * from fruit where f_name like &#x27;b%y&#x27;;# 2.2.6.4 查询所有名称 y结尾 y的前面有5个字符 的水果# 一个下划线代表一个字符select * from fruit where f_name like &#x27;_____y&#x27;;\n\n排序1234567# 2.2.7.1 按照水果价格升序显示select * from fruit order by f_price;select * from fruit order by f_price asc;# 2.2.7.2 按照水果价格降序显示select * from fruit order by f_price desc;# 2.2.7.3 按照供应商升序 如果供应商相同的情况下按照价格降序select * from fruit order by s_id,f_price desc ;\n\n聚合函数123456789101112131415161718192021# 2.2.8.1.1 统计水果种类数量select count(*) as &#x27;total&#x27; from fruit;select count(1) as &#x27;total&#x27; from fruit;select count(f_id) as &#x27;total&#x27; from fruit;# 2.2.8.1.2 统计消费者人数# count(*) 只有该行有记录就统计# count(字段名) 先判断 该字段的值是否为空 如果为空不在统计范围内select count(1) as &#x27;total&#x27; from customer;select count(c_email) as &#x27;total&#x27; from customer;# 2.2.8.2 统计单价最高select max(f_price) as &#x27;max_price&#x27; from fruit;# [42000][1140] In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column &#x27;chap02.fruit.f_name&#x27;; this is incompatible with sql_mode=only_full_group_by# 解决方法1：修改配置文件 取消严格模式# 解决方法2：使用 group by 查询select f_name,max(f_price) as &#x27;max_price&#x27; from fruit;# 2.2.8.3 统计单价最低select min(f_price) as &#x27;min_price&#x27; from fruit;# 2.2.8.4 统计单价总和select sum(f_price) as &#x27;sum_price&#x27; from fruit;# 2.2.8.5 统计平均价格select avg(f_price) as &#x27;avg_price&#x27; from fruit;\n\n去重1234# 2.2.9.1 在水果表查询所有供应商 idselect distinct s_id from fruit;# 2.2.9.2 在水果表中统计所有供应商数量select count(distinct s_id) as &#x27;total_s_id&#x27; from fruit;\n\n分组12# 2.2.10.1 每个供应商供应水果种类数量select s_id,count(*) as &#x27;total&#x27; from fruit group by s_id;\n\n12# 2.2.10.2 每个供应商供应水果种类数量 按照供应水果种类数量降序select s_id,count(*) as &#x27;total&#x27; from fruit group by s_id order by total desc ;\n\n12# 2.2.10.3 每个供应商供应水果种类数量 按照供应水果种类数量降序 如果供应水果种类数量相同则按照供应商编号降序select s_id,count(*) as &#x27;total&#x27; from fruit group by s_id order by total desc ,s_id desc ;\n\n12345678# 2.2.10.4 每笔消费的总金额select * from orderitem;# 2.2.10.4.1 计算每笔流水的小计 小计  = 数量 × 单价# 2.2.10.4.2 计算每笔流水的的小计 小计  = 数量 × 单价 分组# 2.2.10.4.3 计算每笔流水的总金额 小计的和\n\n\n12# 2.2.10.5 每笔消费的总金额 降序\n\n12# 2.2.10.6 每笔消费的总金额 高于200 降序\n\n分页查询\n123456-- LIMIT 起始位置 , 查询数量-- (查询页面号 - 1) * 每页记录数 = 起始位置-- 总页数 = if(总记录数 % 每页记录数 == 0) ? 总记录数 / 每页记录数 : (总记录数 / 每页记录数) + 1select * from fruit limit 0 , 5;select * from fruit limit 5, 5;select * from fruit limit 50, 5;\n\n总结\n\n\n名称\n符号\n\n\n\n比较查询\n&gt;，&lt;，&lt;&#x3D;，&gt;&#x3D;，&#x3D;，!&#x3D;\n\n\n范围查询\nbetween and， in，limit\n\n\n模糊查询\nlike\n\n\nnull查询\nis null，is not null\n\n\n逻辑查询\nand，or，!&#x3D;\n\n\n\nsql语句编写顺序 select 字段 from 表名 where 条件 group by having order by limit\nsql语句执行顺序  from表 -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit\n\n多表查询\n子查询123456789# 2.3.1 子查询 查找水果名为苹果的供应商名 子查询方式查找# 子查询 （嵌套结构）# 子查询嵌入在主查询中# 子查询辅助主查询，要么充当条件，要么充当数据源（数据表）# 子查询可以是独立的语句，自己就是一条完整的 select 语句# 编写步骤 先写子查询再写主查询最后在将子查询与主查询拼接select s.s_id,s.s_name from supplier s where s.s_id = 102;select f.s_id,f.f_name from fruit f where f_name = &#x27;apple&#x27;;select s.s_id,s.s_name from supplier s where s.s_id = (select f.s_id from fruit f where f_name = &#x27;apple&#x27;);\n\n123456# 练习： 每笔消费的总金额 高于200 的订单的消费者信息select * from customer where c_id in (    select c_id from `order` where o_num in (        select o_num from orderitem group by o_num having sum((quantity * item_price)) &gt; 200    ));\n\n交叉查询 cross join\n产生笛卡儿积\n\n12345678910111213SELECT\t`s_name`,\t`s_city`,\t`s_zip`,\t`s_call`,\t`s`.`s_id`,\t`f`.`s_id`,\t`f_id`,\t`f_name`,\t`f_price`FROM\t`supplier` AS s,\t`fruit` AS f\n\n\n1234567891011121314SELECT\t`s_name`,\t`s_city`,\t`s_zip`,\t`s_call`,\t`s`.`s_id`,\t`f`.`s_id`,\t`f_id`,\t`f_name`,\t`f_price`FROM\t`supplier` AS s,\t`fruit` AS fwhere s.s_id = f.s_id;\n\n12345678910111213SELECT\t`s_name`,\t`s_city`,\t`s_zip`,\t`s_call`,\t`s`.`s_id`,\t`f`.`s_id`,\t`f_id`,\t`f_name`,\t`f_price`FROM\t`supplier` AS s cross join `fruit` AS fwhere s.s_id = f.s_id;\n\n\n内连接 inner join\n\n关键字 INNER JOIN\n连接查询条件 ON\n\n\n\n\n1select * from `order` o inner join customer c on o.c_id = c.c_id;\n\n\n左外连接 left outer join\n以左表为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充\n\n\n1select * from `order` o left outer join customer c on o.c_id = c.c_id;\n\n\n右外连接 right outer join\n以右表为主根据条件查询右表数据，如果根据条件查询左表数据不存在使用null值填充\n\n\n1select * from `order` o right outer join customer c on o.c_id = c.c_id;\n\n\n全连接 full join1234567891011121314# FULL JOIN的作用# 在关系型数据库中，我们经常需要将两个或多个表格中的数据进行合并。# FULL JOIN是一种将两个表格中的所有数据进行合并的操作，包括左表格、右表格以及两个表格中都存在的数据。# FULL JOIN可以帮助我们更好地理解数据之间的关系，从而更加高效地进行数据分析和处理。# MySQL中没有FULL JOIN的原因# 尽管FULL JOIN在关系型数据库中非常有用，但是MySQL并不支持FULL JOIN操作。# 这是因为MySQL采用的是基于左表格和右表格的JOIN操作，而没有提供FULL JOIN的实现方式。# 因此，如果我们需要使用FULL JOIN操作，就需要通过其他方式来实现。# 虽然MySQL不支持FULL JOIN操作，但是我们可以通过使用UNION和LEFT JOIN操作来实现FULL JOIN的效果。具体方法如下：# （1）使用UNION操作将左表格和右表格中的数据进行合并。# （2）使用LEFT JOIN操作将左表格和右表格中的数据进行连接，将左表格和右表格中都存在的数据进行合并。# （3）将UNION操作和LEFT JOIN操作的结果进行合并，即可得到FULL JOIN的结果。# 需要注意的是，在使用UNION操作和LEFT JOIN操作时，我们需要保证两个表格中的数据结构相同，否则可能会出现错误。\n\nunion all\n123456789101112# 两张表的数据结构要一致 不会去除重复数据# 查询水果表中 供应商id 是 101 和 102 水果信息select * from fruit where s_id = 101 or  s_id = 102;select * from fruit where s_id in (101, 102);select * from fruit where s_id = 101 union all select * from fruit where s_id = 102;select * from fruit where s_id = 101 union all select * from fruit where s_id = 101;\n\nunion\n1234# 过滤重复数据select * from fruit where s_id = 101 union select * from fruit where s_id = 101;\n\nsome any all![图示_any some](D:&#x2F;dev&#x2F;code&#x2F;vue&#x2F;vue_study&#x2F;bigdata2024&#x2F;MySQL&#x2F;img&#x2F;图示_any some.png)\n123456# 2.3.4.1 someselect * from tbl1 where num1 &gt; some(select * from tbl2);# 2.3.4.2 anyselect * from tbl1 where num1 &gt; any(select * from tbl2);# 2.3.4.3 allselect * from tbl1 where num1 &gt; all(select * from tbl2);\n\nexits12345678910111213141516171819202122232425# 2.3.5 exists# 查找供应商 名字 是否存在select exists (SELECT `s_id` FROM `supplier` WHERE `s_name` = &#x27;ACME&#x27; ) as isExists;select exists (SELECT `s_id` FROM `supplier` WHERE `s_name` = &#x27;李昊哲&#x27; ) as isExists;#  Can&#x27;t create database &#x27;chap02&#x27;; database existscreate database if not exists chap02;drop database if exists chap03;create table if not exists login (  id int auto_increment comment &#x27;主键&#x27;,  phone_number varchar(11) unique not null comment &#x27;手机号&#x27;,  primary key (id));insert into login (phone_number) value (&#x27;15311484568&#x27;);insert into login (phone_number) select &#x27;15311484568&#x27; where not exists     (select phone_number from login where phone_number = &#x27;15311484568&#x27;);insert into login (phone_number) select &#x27;18515697037&#x27; where not exists     (select phone_number from login where phone_number = &#x27;18515697037&#x27;);select * from login;\n\n自关联查询1234desc region_address;select * from region_address where region_name = &#x27;河南&#x27;;select * from region_address where parent_code = 41;select * from region_address where parent_code = 4107;\n\n练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657select * from tb_category;select count(*) from tb_category;# 子查询作为查询条件# 一级导航select * from tb_category where parent_id = 0;# 二级导航select * from tb_category where parent_id in (select id from tb_category where parent_id = 0);# 二级导航select * from tb_category where parent_id in (select id from tb_category where parent_id in (select id from tb_category where parent_id = 0))# 子查询作为数据源 也就是 当中一张数据表看待# 一级导航select * from tb_category where parent_id = 0;# 二级导航select t1.id,name,goods_num,is_menu,is_menu,seq,parent_id,template_id from tb_category t1    inner join    (select id from tb_category where parent_id = 0) t2    on t1.parent_id = t2.id;# 将一级导航和该导航下的二级导航数据封装一次性送到前端select t1.id,name,goods_num,is_menu,is_menu,seq,parent_id,template_id from tb_category t1    inner join    (select id from tb_category where parent_id = 0) t2    on t1.parent_id = t2.id;select parent_id,group_concat(id) from tb_category where parent_id = 0 group by parent_id;select t4.id,name,goods_num,is_menu,is_menu,seq,t4.parent_id,template_id,t3.ids,t3.names from tb_category t4 inner join    (        select parent_id,group_concat(t1.id) ids,group_concat(t1.name) names from tb_category t1        inner join        (select id from tb_category where parent_id = 0) t2        on t1.parent_id = t2.id        group by parent_id    ) t3    on t3.parent_id = t4.id;select t4.id,name,goods_num,is_menu,is_menu,seq,t4.parent_id,template_id,t3.ids,t3.names from tb_category t4 inner join    (        select parent_id,json_array(group_concat(t1.id)) ids,json_array(group_concat(t1.name)) names from tb_category t1        inner join        (select id from tb_category where parent_id = 0) t2        on t1.parent_id = t2.id        group by parent_id    ) t3    on t3.parent_id = t4.id;select t4.id,name,goods_num,is_menu,is_menu,seq,t4.parent_id,template_id,json_array(t3.ids) id_list,json_array(t3.names) name_list from tb_category t4 inner join    (        select parent_id,group_concat(t1.id) ids,group_concat(t1.name) names from tb_category t1        inner join        (select id from tb_category where parent_id = 0) t2        on t1.parent_id = t2.id        group by parent_id    ) t3    on t3.parent_id = t4.id;\n\n函数12345678910# 1、函数# 数学函数、字符串函数、日期时间函数、条件判断、循环函数、系统信息函数、加密解密函数、开窗函数# 1.1 准备数据# mysql -uroot -pcreate database chap03;use chap03;source d:/chap03_data.sql;show tables;# dualselect &#x27;勿忘国耻，振兴中华&#x27; as &#x27;slogan&#x27; from dual;\n\n聚合函数数学函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 1.3 数学函数# 1.3.1 绝对值select abs(3),abs(-3),abs(-3.3) from dual;# 1.3.2 圆周率select pi() as &#x27;pi&#x27; from dual;# 1.3.3 平方根select sqrt(9),sqrt(20),sqrt(-9) from dual;# 1.3.4 取模运算select mod(9,2),mod(6,2),mod(-6,2),mod(-9,2) from dual;# 1.3.5 向上取整select ceil(3.3),ceil(-3.9) from dual;# 1.3.6 向上取整select floor(3.9),floor(-3.3) from dual;# 1.3.7 四舍五入 (x,y) x 是原始值 y 保留小数后面几位select round(3.9),round(3.3),round(-3.9),round(-3.3) from dual;select round(3.1415926,2) from dual;select round(3.145,2) from dual;# 1.3.8 随机数 范围 0~1之间的小数select rand(),rand(),rand() from dual;select round(rand() ,2),round(rand() ,2),round(rand() ,2) from dual;# 1.3.9 随机数 参数x 最接近参数x的随机值select rand(10),rand(-10) from dual;# 1.3.10 符号函数 参数值为整数、零、负数返回结果依次为1、0、-1select sign(3), sign(0) ,sign(-3)from dual;# 1.3.11 幂运算函数# 1.3.11.1 幂运算函数 (x,y)select pow(2,2),pow(3,3), pow(2,-2),pow(-2,2),pow(-2,3) from dual;# 1.3.11.2 幂运算函数 (x,y)select power(2,2),power(3,3), power(2,-2),power(-2,2),power(-2,3) from dual;# 1.3.11.3 幂运算函数 e 的乘方select exp(2),exp(3) from dual;# 1.3.12 对数运算函数select log(3),log(0),log(-3) from dual;# 1.3.13 角度与弧度互转函数# 1.3.13.1 角度转弧度select radians(90),radians(180) from dual;# 1.3.13.2 弧度转角度select degrees(pi()),degrees(pi()/2) from dual;# 1.3.14 正弦函数select sin(0),sin(1),sin(pi()) from dual;# 1.3.15 正余弦函数select cos(0),cos(1),cos(pi()) from dual;# 1.3.16 余弦函数select acos(0),acos(1),acos(pi()) from dual;# 1.3.17 正切函数select tan(0.3) from dual;# 1.3.18 反正切函数select atan(0.3) from dual;# 1.3.19 反正切函数select cot(3.23) from dual;\n\n字符串函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 1.4 字符串函数# 1.4.1 char_length 计算字符串字符数量select char_length(&#x27;我爱你中国&#x27;) from dual;# 1.4.2 length 计算字符串长度 单位字节select length(&#x27;我爱你中国&#x27;) from dual;select char_length(&#x27;I love China&#x27;) from dual;select length(&#x27;I love China&#x27;) from dual;# 1.4.3 concat 字符串拼接select concat(&#x27;I&#x27;,&#x27; &#x27;, &#x27;love&#x27;, &#x27; &#x27;, &#x27;China&#x27;) from dual;select concat(&#x27;1983&#x27;,&#x27;-&#x27;, &#x27;11&#x27;, &#x27;-&#x27;, &#x27;22&#x27;) from dual;# 注意：在oracle中concat只能传两个参数select concat(&#x27;1983&#x27;,concat(&#x27;-&#x27;,concat(&#x27;11&#x27;,concat(&#x27;-&#x27;, &#x27;22&#x27;)))) from dual;# oracle 语法 select &#x27;1983&#x27;||&#x27;-&#x27;||&#x27;11&#x27;||&#x27;-&#x27;||&#x27;22&#x27; from dual;# 1.4.4 concat_ws 带连接符号的字符串拼接 第一个参数为连接符select concat_ws(&#x27;-&#x27;,&#x27;1983&#x27;, &#x27;11&#x27;,&#x27;22&#x27;) from dual;select concat_ws(&#x27; &#x27;,&#x27;I&#x27;, &#x27;love&#x27;, &#x27;China&#x27;) from dual;# 1.4.5 insert 字符串替换# 第一个参数是源字符串，第二个参数是该字符串的第几个字符,第三次参数是长度，第四个参数是替换后的内容select insert (&#x27;桃李不言下自成蹊&#x27;,2,4,&#x27;what&#x27;) from dual;# 1.4.6 lower 字符串中字母转小写select lower(&#x27;I Love CHINA&#x27;) from dual;# 1.4.7 upper 字符串中字母转大写select upper(&#x27;i love china&#x27;) from dual;# 1.4.8 left 返回字符串中左边的字符select left(&#x27;桃李不言下自成蹊&#x27;,2) from dual;# 1.4.9 right 返回字符串中有边的字符select right(&#x27;桃李不言下自成蹊&#x27;,2) from dual;# 1.4.10 lpad 字符串左边填充# 第一个参数是原字符串 第二个参数填充后的字符串长度 第三个参数是填充值select lpad(&#x27;桃李不言下自成蹊&#x27;,3,&#x27;李昊哲&#x27;) from dual;select lpad(&#x27;桃李不言下自成蹊&#x27;,char_length(&#x27;桃李不言下自成蹊&#x27;) + 3,&#x27;李昊哲&#x27;) from dual;# 注意：填充后的长度 如果超过了 源字符串长度+填充内容长度 填充内容会重复填充select lpad(&#x27;桃李不言下自成蹊&#x27;,char_length(&#x27;桃李不言下自成蹊&#x27;) + 6,&#x27;李昊哲&#x27;) from dual;# 1.4.11 rpad 字符串右边填充select rpad(&#x27;桃李不言下自成蹊&#x27;,3,&#x27;李昊哲&#x27;) from dual;select rpad(&#x27;桃李不言下自成蹊&#x27;,char_length(&#x27;桃李不言下自成蹊&#x27;) + 3,&#x27;李昊哲&#x27;) from dual;# 注意：填充后的长度 如果超过了 源字符串长度+填充内容长度 填充内容会重复填充select rpad(&#x27;桃李不言下自成蹊&#x27;,char_length(&#x27;桃李不言下自成蹊&#x27;) + 6,&#x27;李昊哲&#x27;) from dual;# 1.4.12 ltrim 删除字符串左边空格select &#x27;   桃 李 不 言 下 自 成 蹊   &#x27; from dual;select ltrim(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;) from dual;# 1.4.13 rtrim 删除字符串右边空格select char_length(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;) from dual;select rtrim(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;) from dual;select char_length(rtrim(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;)) from dual;# 1.4.14 trim 删除字符串左右边空格select trim(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;) from dual;select char_length(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;) from dual;select char_length(trim(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;)) from dual;# 1.4.15 trim(s1 from s2) 删除左右两端指定字符串函数select trim(&#x27;xyz&#x27; from &#x27;xyzabcxyzabcxyzabcxyz&#x27;) from dual;# 1.4.16 repeat 重复生成相同的字符串select repeat(&#x27;爱我中华&#x27;,3) from dual;# 1.4.17 space 生成由空格组成的字符串select concat_ws(space(6),&#x27;爱&#x27;,&#x27;我&#x27;,&#x27;中&#x27;,&#x27;华&#x27;) from dual;# 1.4.18 replace 字符串替换select &#x27;我爱你你爱我，我们一起甜蜜蜜&#x27; from dual;select insert(&#x27;我爱你你爱我，我们一起甜蜜蜜&#x27;,4,3,&#x27;李昊哲&#x27;) from dual;select replace(&#x27;我爱你你爱我，我们一起甜蜜蜜&#x27;,&#x27;你爱我&#x27;,&#x27;李昊哲&#x27;) from dual;select replace(&#x27;你爱我你爱我，我们一起甜蜜蜜&#x27;,&#x27;你爱我&#x27;,&#x27;李昊哲&#x27;) from dual;select replace(&#x27;   桃 李 不 言 下 自 成 蹊   &#x27;,&#x27; &#x27;,&#x27;&#x27;) from dual;# 1.4.19 ascii 将 ascii 字符转为 ascii 码 字符串替换select ascii(&#x27;a&#x27;)  from dual;select ascii(&#x27;b&#x27;)  from dual;# 1.4.20 strcmp 比较字符大小 返回值为正数 为第一个参数比第二个参数大 反之第二个参数比第一个参数大 返回值为零两个参数一样大select strcmp(&#x27;a&#x27;,&#x27;b&#x27;)  from dual;select strcmp(&#x27;李&#x27;,&#x27;王&#x27;)  from dual;# 1.4.21 substring 字符串截取 第一个参数为原字符串 第二个参数为截取位置 位置从1开始 第三个参数为截取长度select substring(&#x27;桃李不言下自成蹊&#x27;,2,3) from dual;select substr(&#x27;桃李不言下自成蹊&#x27;,2,3) from dual;# 1.4.22 mid 字符串截取 第一个参数为原字符串 第二个参数为截取位置 位置从1开始 第三个参数为截取长度select mid(&#x27;桃李不言下自成蹊&#x27;,2,3) from dual;# 1.4.23 locate 查找字符串中指定字符串第一次出现的位置 第一个参数是字符串中出现的字符串 返回值为零代表没有出现过select locate(&#x27;你爱我&#x27;,&#x27;我爱你你爱我我爱你你爱我&#x27;)  from dual;select locate(&#x27;蜜雪冰城&#x27;,&#x27;我爱你你爱我我爱你你爱我&#x27;)  from dual;# 1.4.24 reverse 逆序select reverse(&#x27;我爱你&#x27;) from dual;# 1.4.25 elt 返回指定位置的字符串 第一个参数是指定位置值select elt(3,&#x27;我&#x27;,&#x27;真&#x27;,&#x27;的&#x27;,&#x27;很&#x27;,&#x27;爱&#x27;,&#x27;你&#x27;) from dual;\n\n日期时间函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 1.5 日期时间函数# 1.5.1 获取当前日期select curdate(),current_date() from dual;# 1.5.2 获取当前时间select curtime(),current_time() from dual;# 1.5.3 获取当前日期和时间select sysdate(),now(),localtime(),current_timestamp() from dual;# 1.5.4 获取当前时间戳select unix_timestamp(), unix_timestamp(now()),unix_timestamp(&#x27;1983-11-22 20:30:00&#x27;),from_unixtime(438352200) from dual;# 1.5.5 获取UTC时间select utc_date(),utc_time(),utc_timestamp() from dual;# 1.5.6 单独获取年、月、日、小时、分钟、秒、星期select year(now()), month(now()),day(now()),dayofmonth(now()),hour(now()),minute(now()),second(now()) from dual;# weekday 从零开始select week(now()), weekday(now()),weekofyear(now()) from dual;# 1.5.7 提取获取年、月、日、小时、分钟、秒、星期select year(&#x27;1983-11-22 20:30:00&#x27;)  from dual;select extract(year from &#x27;1983-11-22 20:30:00&#x27;) from dual;# 1.5.8 时间加减操作select now(),date_add(now(), interval 1 year ) from dual;select now(),date_add(now(), interval 1 month ) from dual;select now(),date_add(now(), interval 1 day ) from dual;select now(),date_add(now(), interval 1 hour ) from dual;select now(),date_add(now(), interval 1 minute ) from dual;select now(),date_add(now(), interval 1 second ) from dual;select now(),subdate(now(), interval 1 year ) from dual;select now(),subdate(now(), interval 1 month ) from dual;select now(),subdate(now(), interval 1 day ) from dual;select now(),subdate(now(), interval 1 hour ) from dual;select now(),subdate(now(), interval 1 minute ) from dual;select now(),subdate(now(), interval 1 second ) from dual;# 1.5.9 计算时间间隔天数select datediff(&#x27;2023-09-28 15:01:01&#x27;,&#x27;2023-09-27 16:03:03&#x27;) from dual;# 1.5.10 日期格式化输出# %Y 4位年份# %y 2位年份# %M 月份全名# %b 月份缩写# %m 2位月份# %D 当月第几天 数字th# %d 2位日期# %H 24小时# %h 12小时# %i 2位分钟# %s 2位秒# %W 星期全名# %w 星期缩写select now(),date_format(now(),&#x27;%Y/%m/%d %H:%i:%s&#x27;) from dual;# 1.5.11 时间格式化输出select now(),time_format(now(),&#x27;%Y/%m/%d %H:%i:%s&#x27;) from dual;\n\n选择函数12345678# 1.6 选择判断函数# 1.6.1 第一个参数是条件表达式 条件表达式返回值为true返回第二个参数 条件表达式返回值为false返回第三个参数select if(true,&#x27;成立&#x27;,&#x27;不成立&#x27;) from dual;select if(false,&#x27;成立&#x27;,&#x27;不成立&#x27;) from dual;select if(1,&#x27;成立&#x27;,&#x27;不成立&#x27;) from dual;select if(0,&#x27;成立&#x27;,&#x27;不成立&#x27;) from dual;select if(-1,&#x27;成立&#x27;,&#x27;不成立&#x27;) from dual;\n\n12345678910111213# 1.6.2# use chap04;# select score from scores;# # 90以上A 80~90B 70~80C 60~70D 60以下E# select s_id,c_id,#        case#            when score &gt;= 90 then &#x27;A&#x27;#            when score &gt;= 80 then &#x27;B&#x27;#            when score &gt;= 70 then &#x27;C&#x27;#            when score &gt;= 60 then &#x27;D&#x27;#            else &#x27;E&#x27;#         end as &#x27;level&#x27;#        from scores;\n\n开窗函数\n能为每行数据划分一个窗口，然后对窗口范围内的数据进行计算，最后将计算结果返回给该行\n\n12345678910Function(arg1,..., argn) OVER ([PARTITION BY &lt;...&gt;] [ORDER BY &lt;....&gt;] [&lt;window_expression&gt;])-- 其中Function(arg1,..., argn) 可以是下面分类中的任意一个    -- 聚合函数：比如sum max min avg count等    -- 排序函数：比如row_number rank dense_rank等    -- 分析函数：比如lead lag first_value last_value等-- OVER [PARTITION BY &lt;...&gt;] 类似于group by 用于指定分组  每个分组你可以把它叫做窗口-- 如果没有PARTITION BY 那么整张表的所有行就是一组-- [ORDER BY &lt;....&gt;]  用于指定每个分组内的数据排序规则 支持ASC、DESC-- [&lt;window_expression&gt;] 用于指定每个窗口中 操作的数据范围 默认是窗口中所有行\n\n12345678# 1.7.1 查询各科成绩前三名的学生-- row_number() over () 连续序号-- over()里头的分组以及排序的执行晚于 where 、group by、order by 的执行。 select c_id ,score, row_number() over () as &#x27;num&#x27; from scores;# partition by 作用相当于 group by select c_id ,score, row_number() over (partition by c_id) as &#x27;num&#x27; from scores;# order by 写在 开窗函数内 局部排序 select c_id ,score, row_number() over (partition by c_id order by score desc ) as &#x27;num&#x27; from scores;\n\n12345678-- row_number() over () 连续序号-- over()里头的分组以及排序的执行晚于 where 、group by、order by 的执行。select * from(    select s_id,c_id ,score,       row_number() over (partition by c_id order by score desc ) as &#x27;num&#x27;        from scores) t where t.num &lt; 4;\n\n1234567-- rank() over () 排名 跳跃排序 序号不是连续的select * from(    select s_id,c_id ,score,       rank() over (partition by c_id order by score desc ) as &#x27;num&#x27;        from scores) t where t.num &lt; 4;\n\n1234567-- dense_rank() over () 排名 连续排序select * from(    select s_id,c_id ,score,       dense_rank() over (partition by c_id order by score desc ) as &#x27;num&#x27;        from scores) t where t.num &lt; 4;\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n行列转换列转行1234567create table test (    stu_name varchar(50),    course_name varchar(50),    score int);insert into test values (&#x27;张三&#x27;,&#x27;语文&#x27;,&#x27;80&#x27;),(&#x27;张三&#x27;,&#x27;数学&#x27;,&#x27;90&#x27;), (&#x27;李四&#x27;,&#x27;语文&#x27;,&#x27;85&#x27;),(&#x27;李四&#x27;,&#x27;数学&#x27;,&#x27;95&#x27;);select * from test;\n\n\n12345678# 1.9.1 列转行create table test (    stu_name varchar(50),    course_name varchar(50),    score int);insert into test values (&#x27;张三&#x27;,&#x27;语文&#x27;,&#x27;80&#x27;),(&#x27;张三&#x27;,&#x27;数学&#x27;,&#x27;90&#x27;), (&#x27;李四&#x27;,&#x27;语文&#x27;,&#x27;85&#x27;),(&#x27;李四&#x27;,&#x27;数学&#x27;,&#x27;95&#x27;);select * from test;\n\n1234select stu_name,       case when course_name = &#x27;语文&#x27; then score end as &#x27;yuwen&#x27;,       case when course_name = &#x27;数学&#x27; then score end as &#x27;shuxue&#x27;       from test;\n\n123456-- null 在 比较的时候 是最小值select stu_name,       max(case when course_name = &#x27;语文&#x27; then score end) as &#x27;yuwen&#x27;,       max(case when course_name = &#x27;数学&#x27; then score end) as &#x27;shuxue&#x27;       from testgroup by stu_name;\n\n行转列123456789# 1.9.2 行转列create table sales (    emp_name varchar(50),    january int,    february int,    March int);insert into sales values (&#x27;张三&#x27;,1000,2000,3000),(&#x27;李四&#x27;,1500,2500,3500);select * from sales;\n\n\n123456select emp_name, &#x27;january&#x27; as &#x27;yue&#x27;, january from salesunion allselect emp_name,&#x27;february&#x27; as &#x27;yue&#x27;, february from salesunion allselect emp_name,&#x27;March&#x27; as &#x27;yue&#x27;, March from salesorder by  emp_name;\n\n12345678910111213select emp_name,yue_list,       substring_index(substring_index(yue_list,&#x27;,&#x27;,1),&#x27;,&#x27;,-1) as &#x27;january&#x27;,       substring_index(substring_index(yue_list,&#x27;,&#x27;,2),&#x27;,&#x27;,-1) as &#x27;february&#x27;,       substring_index(substring_index(yue_list,&#x27;,&#x27;,3),&#x27;,&#x27;,-1) as &#x27;March&#x27;from    (select emp_name ,group_concat(t.yue) as yue_list from        (select emp_name,january as &#x27;yue&#x27; from sales         union all        select emp_name,february as &#x27;yue&#x27; from sales        union all        select emp_name,March as &#x27;yue&#x27; from sales        order by emp_name) tgroup by t.emp_name) t1;\n\n身份证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 1.10 身份证# 第1位和第2位数字代表出生省份地区码# 第3位和第4位数字代表出生省份所辖城市地区码# 第5位和第6位数字代表出生省份所辖城市所辖区县地区码# 第7、8、9、10位数字代表出生出生年份# 第11、12位数字代表出生出生月份# 第13、14位数字代表出生出生日期# 第15、16位顺序码# 第17位数字代表性别 奇数代表男性 偶数代表女性# 第18位数字代表校验码m，用于验证身份证号码的合法性# 1.10.1 计算性别select * from person;select * ,substring(id_card,17,1) as &#x27;gender&#x27; from person;select * ,mod(substring(id_card,17,1),2) as &#x27;gender&#x27; from person;select * ,if(mod(substring(id_card,17,1),2),&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;gender&#x27; from person;select    if(mod(substring(id_card,17,1),2),&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;gender&#x27; ,    count(*)    from person group by gender;# 1.10.2 按照出生日期排序select * ,substring(id_card,7,8) as &#x27;date_of_birth&#x27; from person order by date_of_birth desc;# 1.10.3 计算年龄# 方式一：子查询select id, id_card, first_name, last_name, mobile, auth_text, date_of_birth,    # 当前月份 - 出生月份 &gt; 0 说明已经过完生日了 直接返回 之前计算的年纪    if(month(curdate()) - month(date_of_birth) &gt; 0,age,        # 当前月份 - 出生月份 &lt; 0 说明还没有过生日 直接返回 年纪 = 之前计算的年纪 - 1        if(month(curdate()) - month(date_of_birth) &lt; 0,age - 1,            # 当前月份 - 出生月份 = 0            # 当前日期 - 出生日期 &gt; 0 说明已经过完生日了 直接返回 之前计算的年纪            # 当前日期 - 出生日期 &lt;= 0 说明还没有过生日 直接返回 年纪 = 之前计算的年纪 - 1            if(day(curdate()) - day(date_of_birth) &gt; 0,age,age - 1)        )    ) as &#x27;age&#x27;    from    (select id, id_card, first_name, last_name, mobile, auth_text, date_of_birth,            # 当前年份 - 出生日期 = 年纪           (year(curdate()) - year(date_of_birth)) as &#x27;age&#x27;        from            # 从身份证截取出生日期        (select * ,substring(id_card,7,8) as &#x27;date_of_birth&#x27; from person ) t1) t2;# 方式二：反复调用时间函数select id, id_card, first_name, last_name, mobile, auth_text,    # 当前月份 - 出生月份 &gt; 0 说明已经过完生日了 直接返回 之前计算的年纪    if(month(curdate()) - month(substring(id_card,7,8)) &gt; 0,        month(curdate()) - month(substring(id_card,7,8)),        # 当前月份 - 出生月份 &lt; 0 说明还没有过生日 直接返回 年纪 = 之前计算的年纪 - 1        if(month(curdate()) - month(substring(id_card,7,8)) &lt; 0,            month(curdate()) - month(substring(id_card,7,8)) - 1,            # 当前月份 - 出生月份 = 0            # 当前日期 - 出生日期 &gt; 0 说明已经过完生日了 直接返回 之前计算的年纪            # 当前日期 - 出生日期 &lt;= 0 说明还没有过生日 直接返回 年纪 = 之前计算的年纪 - 1            if(day(curdate()) - day(substring(id_card,7,8)) &gt; 0,               month(curdate()) - month(substring(id_card,7,8)),               month(curdate()) - month(substring(id_card,7,8)) - 1)        )    ) as &#x27;age&#x27;    from person;\n\njson1234select &#x27;&#123;&quot;name&quot;:&quot;李昊哲&quot;,&quot;firends&quot;:[&quot;温柔&quot;,&quot;知性&quot;,&quot;美丽&quot;,&quot;大方&quot;]&#125;&#x27; from dual;select json_extract(&#x27;&#123;&quot;name&quot;:&quot;李昊哲&quot;,&quot;firends&quot;:[&quot;温柔&quot;,&quot;知性&quot;,&quot;美丽&quot;,&quot;大方&quot;]&#125;&#x27;,&#x27;$.name&#x27;) as name from dual;select json_extract(&#x27;&#123;&quot;name&quot;:&quot;李昊哲&quot;,&quot;firends&quot;:[&quot;温柔&quot;,&quot;知性&quot;,&quot;美丽&quot;,&quot;大方&quot;]&#125;&#x27;,&#x27;$.firends&#x27;) as firends from dual;select json_extract(&#x27;&#123;&quot;name&quot;:&quot;李昊哲&quot;,&quot;firends&quot;:[&quot;温柔&quot;,&quot;知性&quot;,&quot;美丽&quot;,&quot;大方&quot;]&#125;&#x27;,&#x27;$.firends[1]&#x27;) as firend from dual;\n\n视图12345678910111213141516171819202122232425262728293031323334353637383940414243create view person_view as select * from person;select * from person_view;update person set mobile = &#x27;13427468302&#x27; where id = 1 ;update person_view set mobile = &#x27;13427468303&#x27; where id = 1 ;drop view person_view;create view person_view as    select id, id_card, first_name, last_name, mobile, auth_text, date_of_birth,    # 当前月份 - 出生月份 &gt; 0 说明已经过完生日了 直接返回 之前计算的年纪    if(month(curdate()) - month(date_of_birth) &gt; 0,age,        # 当前月份 - 出生月份 &lt; 0 说明还没有过生日 直接返回 年纪 = 之前计算的年纪 - 1        if(month(curdate()) - month(date_of_birth) &lt; 0,age - 1,            # 当前月份 - 出生月份 = 0            # 当前日期 - 出生日期 &gt; 0 说明已经过完生日了 直接返回 之前计算的年纪            # 当前日期 - 出生日期 &lt;= 0 说明还没有过生日 直接返回 年纪 = 之前计算的年纪 - 1            if(day(curdate()) - day(date_of_birth) &gt; 0,age,age - 1)        )    ) as &#x27;age&#x27;,mod(substring(id_card,17,1),2) as &#x27;gender&#x27;    from    (select id, id_card, first_name, last_name, mobile, auth_text, date_of_birth,            # 当前年份 - 出生日期 = 年纪           (year(curdate()) - year(date_of_birth)) as &#x27;age&#x27;        from            # 从身份证截取出生日期        (select * ,substring(id_card,7,8) as &#x27;date_of_birth&#x27; from person ) t1) t2;create table person_new(    id         int auto_increment comment &#x27;主键&#x27;        primary key,    id_card    varchar(18)  not null,    first_name varchar(15)  not null,    last_name  varchar(15)  not null,    mobile     varchar(11)  not null,    auth_text  varchar(255) null);insert into person_new select * from person;select * from person_new;\n\n\n\n事务1234567 select @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+1 row in set (0.00 sec)\n\n1SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n\n12345678910select @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+1 row in set (0.00 sec)mysql&gt; \n\n\n\n\n隔离级别\n脏读\n不可重复读\n幻影读\n\n\n\nREAD-UNCOMMITTED\n√\n√\n√\n\n\nREAD-COMMITTED\n×\n√\n√\n\n\nREPEATABLE-READ\n×\n×\n√\n\n\nSERIALIZABLE\n×\n×\n×\n\n\n表分区表分区介绍\nMySQL 数据库中的数据是以文件的形势存在磁盘上的，\n默认放在 /var/lib/mysql/ 目录下面，\n我们可以通过 show variables like &#39;%datadir%&#39;; 命令来查看：\n\n1show variables like &#x27;%datadir%&#x27;;\n\n\n\n我们进入到这个目录下，就可以看到我们定义的所有数据库了，\n一个数据库就是一个目录，一个库中，有其对应的表的信息，如下：\n\n1cd /var/lib/mysql\n\n1ls\n\n\n优点：\n\n查询性能提升：分区可以将大表划分为更小的部分，查询时只需扫描特定的分区，而不是整个表，从而提高查询性能。特别是在处理大量数据或高并发负载时，分区可以显著减少查询的响应时间。\n管理和维护的简化：使用分区可以更轻松地管理和维护数据。可以针对特定的分区执行维护操作，如备份、恢复、优化和数据清理，而不必处理整个表。这简化了维护任务并减少了操作的复杂性。\n数据管理灵活性：通过分区，可以根据业务需求轻松地添加或删除分区，而无需影响整个表。这使得数据的增长和变化更具弹性，可以根据需求进行动态调整。\n改善数据安全性和可用性：可以将不同分区的数据分布在不同的存储设备上，从而提高数据的安全性和可用性。例如，可以将热数据放在高速存储设备上，而将冷数据放在廉价存储设备上，以实现更高的性能和成本效益。\n\n缺点：\n\n复杂性增加：分区引入了额外的复杂性，包括分区策略的选择、表结构的设计和维护、查询逻辑的调整等。正确地设置和管理分区需要一定的经验和专业知识。\n索引效率下降：对于某些查询，特别是涉及跨分区的查询，可能会导致索引效率下降。由于查询需要在多个分区之间进行扫描，可能无法充分利用索引优势，从而影响查询性能。\n存储空间需求增加：使用分区会导致一定程度的存储空间浪费。每个分区都需要占用一定的存储空间，包括分区元数据和一些额外的开销。因此，对于分区键的选择和分区粒度的设置需要权衡存储空间和性能之间的关系。\n功能限制：在某些情况下，分区可能会限制某些MySQL的功能和特性的使用。例如，某些类型的索引可能无法在分区表上使用，或者某些DDL操作可能需要更复杂的处理。\n\n\n在考虑使用分区时，需要综合考虑业务需求、查询模式、数据规模和硬件资源等因素，\n并权衡分区带来的优势和缺点。对于特定的应用和数据场景，\n分区可能是一个有效的解决方案，但并不适用于所有情况。\n\n同时分区表也存在一些限制，如下：\n限制：\n\n在mysql5.6.7之前的版本，一个表最多有1024个分区；从5.6.7开始，一个表最多可以有8192个分区。\n分区表无法使用外键约束。\nNULL值会使分区过滤无效。\n所有分区必须使用相同的存储引擎。\n\n分区适用场景分区表在以下情况下可以发挥其优势，适用于以下几种使用场景：\n\n大型表处理：当面对非常大的表时，分区表可以提高查询性能。通过将表分割为更小的分区，查询操作只需要处理特定的分区，从而减少扫描的数据量，提高查询效率。这在处理日志数据、历史数据或其他需要大量存储和高性能查询的场景中非常有用。\n时间范围查询：对于按时间排序的数据，分区表可以按照时间范围进行分区，每个分区包含特定时间段内的数据。这使得按时间范围进行查询变得更高效，例如在某个时间段内检索数据、生成报表或执行时间段的聚合操作。\n数据归档和数据保留：分区表可用于数据归档和数据保留的需求。旧数据可以归档到单独的分区中，并将其存储在低成本的存储介质上。同时，可以保留较新数据在高性能的存储介质上，以便快速查询和操作。\n并行查询和负载均衡：通过哈希分区或键分区，可以将数据均匀地分布在多个分区中，从而实现并行查询和负载均衡。查询可以同时在多个分区上进行，并在最终合并结果，提高查询性能和系统吞吐量。\n数据删除和维护：使用分区表，可以更轻松地删除或清理不再需要的数据。通过删除整个分区，可以更快速地删除大量数据，而不会影响整个表的操作。此外，可以针对特定分区执行维护任务，如重新构建索引、备份和优化，以减少对整个表的影响。\n\n分区表并非适用于所有情况。在选择使用分区表时，需要综合考虑数据量、查询模式、存储资源和硬件能力等因素，并评估分区对性能和管理的影响。\n分区策略\n\nRANGE分区\n\n\nRANGE分区RANGE分区是MySQL中的一种分区策略，根据某一列的范围值将数据分布到不同的分区。\n每个分区包含特定的范围。下面是RANGE分区的定义方式、特点以及代码示例。\n定义方式：\n\n指定分区键：选择作为分区依据的列作为分区键，通常是日期、数值等具有范围特性的列。\n分区函数：通过PARTITION BY RANGE指定使用RANGE分区策略。\n定义分区范围：使用VALUES LESS THAN子句定义每个分区的范围。\n\nRANGE分区的特点：\n\n范围划分：根据指定列的范围进行分区，适用于需要按范围进行查询和管理的情况。\n灵活的范围定义：可以定义任意数量的分区，并且每个分区可以具有不同的范围。\n高效查询：根据查询条件的范围，MySQL能够快速定位到特定的分区，提高查询效率。\n动态管理：可以根据业务需求轻松添加或删除分区，适应数据增长或变更的需求。\n\n以下是一个使用RANGE分区的代码示例：\n12345678910111213create table sale(\tsale_id int,    sale_date date,    amount decimal(10,2)) partition by range(year(sale_date))(    partition p0 values less than (2020),    partition p1 values less than (2021),    partition p2 values less than (2022),    partition p3 values less than (2023),    partition p4 values less than (2024),    partition p5 values less than (2025));\n\n123456789insert into sale values (1,&#x27;2020-11-11&#x27;,9999.00);insert into sale values (2,&#x27;2020-12-12&#x27;,6666.00);insert into sale values (3,&#x27;2021-11-11&#x27;,12000.00);insert into sale values (4,&#x27;2021-12-12&#x27;,13000.00);insert into sale values (5,&#x27;2022-11-11&#x27;,13000.00);insert into sale values (6,&#x27;2022-12-12&#x27;,12500.00);insert into sale values (7,&#x27;2023-11-11&#x27;,12500.00);insert into sale values (8,&#x27;2023-12-12&#x27;,13000.00);\n\n12select * from sale partition(p0);select * from sale partition(p1);\n\n\nLIST分区LIST分区是根据某一列的离散值将数据分布到不同的分区。每个分区包含特定的列值列表。下面是LIST分区的定义方式、特点以及代码示例。定义方式：\n\n指定分区键：选择作为分区依据的列作为分区键，通常是具有离散值的列，如地区、类别等。\n分区函数：通过PARTITION BY LIST指定使用LIST分区策略。\n定义分区列表：使用VALUES IN子句定义每个分区包含的列值列表。\n\nLIST分区的特点：\n\n列值离散：根据指定列的具体取值进行分区，适用于具有离散值的列。\n灵活的分区定义：可以定义任意数量的分区，并且每个分区可以具有不同的列值列表。\n高效查询：根据查询条件的列值直接定位到特定分区，提高查询效率。\n动态管理：可以根据业务需求轻松添加或删除分区，适应数据增长或变更的需求。\n\n以下是一个使用LIST分区的代码示例：\n12345678910111213create table people(\tid_card varchar(18),    name varchar(50),    province int) partition by list(province)(    partition huabei values in (11,12,13,14,15),    partition dongbei values in (21,22,23),    partition huazhong values in (31,32,33,34,35,36,37),    partition huadong values in (41,42,43,44,45,46),    partition xinan values in (50,51,52,53,55),    partition xibei values in (61,62,63,64,65),    partition gang_ao_tai values in (71,81,91));\n\n12345678910111213141516insert into people values (&#x27;410182198903224674&#x27;,&#x27;邱赣&#x27;,41);insert into people values (&#x27;411429199211019071&#x27;,&#x27;何天&#x27;,41);insert into people values (&#x27;310182198903224674&#x27;,&#x27;方加牡&#x27;,31);insert into people values (&#x27;210182198903224674&#x27;,&#x27;贺巧&#x27;,21);insert into people values (&#x27;110182198903224674&#x27;,&#x27;闾丘饱乾&#x27;,11);insert into people values (&#x27;510182198903224674&#x27;,&#x27;丁经&#x27;,51);insert into people values (&#x27;610182198903224674&#x27;,&#x27;韦散&#x27;,61);insert into people values (&#x27;710182198903224674&#x27;,&#x27;东方让&#x27;,71);insert into people values (&#x27;810182198903224674&#x27;,&#x27;赖队瞻&#x27;,81);insert into people values (&#x27;910182198903224674&#x27;,&#x27;郭叹&#x27;,91);insert into people values (&#x27;120182198903224674&#x27;,&#x27;慕容芋岛&#x27;,12);insert into people values (&#x27;220182198903224674&#x27;,&#x27;孙劣&#x27;,22);insert into people values (&#x27;320182198903224674&#x27;,&#x27;王桃&#x27;,32);insert into people values (&#x27;420182198903224674&#x27;,&#x27;郝郑惭&#x27;,42);insert into people values (&#x27;520182198903224674&#x27;,&#x27;余烂&#x27;,52);insert into people values (&#x27;620182198903224674&#x27;,&#x27;宇文酚&#x27;,62);\n\n123456select * from people partition(huabei);select * from people partition(dongbei);select * from people partition(huazhong);select * from people partition(huadong);select * from people partition(xibei);select * from people partition(gang_ao_tai);\n\nHASH分区HASH分区是使用哈希算法将数据均匀地分布到多个分区中。下面是HASH分区的定义方式、特点以及代码示例。定义方式：\n\n指定分区键：选择作为分区依据的列作为分区键。\n分区函数：通过PARTITION BY HASH指定使用HASH分区策略。\n定义分区数量：使用PARTITIONS关键字指定分区的数量。\n\nHASH分区的特点：\n\n数据均匀分布：HASH分区使用哈希算法将数据均匀地分布到不同的分区中，确保数据在各个分区之间平衡。\n并行查询性能：通过将数据分散到多个分区，HASH分区可以提高并行查询的性能，多个查询可以同时在不同分区上执行。\n简化管理：HASH分区使得数据管理更加灵活，可以轻松地添加或删除分区，以适应数据增长或变更的需求。\n\n以下是一个使用HASH分区的代码示例：\n1234567create table user (    id int auto_increment,    name varchar(50),    primary key (id)) partition by hash (id) partitions 4;\n\n12345678910111213141516insert into user (name) values (&#x27;邱赣&#x27;);insert into user (name) values (&#x27;何天&#x27;);insert into user (name) values (&#x27;方加牡&#x27;);insert into user (name) values (&#x27;贺巧&#x27;);insert into user (name) values (&#x27;闾丘饱乾&#x27;);insert into user (name) values (&#x27;丁经&#x27;);insert into user (name) values (&#x27;韦散&#x27;);insert into user (name) values (&#x27;东方让&#x27;);insert into user (name) values (&#x27;赖队瞻&#x27;);insert into user (name) values (&#x27;郭叹&#x27;);insert into user (name) values (&#x27;慕容芋岛&#x27;);insert into user (name) values (&#x27;孙劣&#x27;);insert into user (name) values (&#x27;王桃&#x27;);insert into user (name) values (&#x27;郝郑惭&#x27;);insert into user (name) values (&#x27;余烂&#x27;);insert into user (name) values (&#x27;宇文酚&#x27;);\n\n1select * from user;\n\n1select * from user partition(p0);\n\n1select * from user partition(p1);\n\n1select * from user partition(p2);\n\n1select * from user partition(p3);\n\nKEY分区KEY分区是根据某一列的哈希值将数据分布到不同的分区。不同于HASH分区，KEY分区使用的是列值的哈希值而不是哈希函数。下面是KEY分区的定义方式、特点以及代码示例。\n定义方式：\n\n指定分区键：选择作为分区依据的列作为分区键。\n分区函数：通过PARTITION BY KEY指定使用KEY分区策略。\n定义分区数量：使用PARTITIONS关键字指定分区的数量。\n\nKEY分区的特点：\n\n哈希分布：KEY分区使用列值的哈希值将数据分布到不同的分区中，与哈希函数不同，它使用的是列值的哈希值。\n高度自定义：KEY分区允许根据业务需求自定义分区逻辑，可以灵活地选择分区键和分区数量。\n并行查询性能：通过将数据分散到多个分区，KEY分区可以提高并行查询的性能，多个查询可以同时在不同分区上执行。\n简化管理：KEY分区使得数据管理更加灵活，可以轻松地添加或删除分区，以适应数据增长或变更的需求。\n\n以下是一个使用KEY分区的代码示例：\n1234567create table person (    id int auto_increment,    name varchar(50),    primary key (id)) partition by key(id) partitions 4;\n\n12345678910111213141516insert into person (name) values (&#x27;邱赣&#x27;);insert into person (name) values (&#x27;何天&#x27;);insert into person (name) values (&#x27;方加牡&#x27;);insert into person (name) values (&#x27;贺巧&#x27;);insert into person (name) values (&#x27;闾丘饱乾&#x27;);insert into person (name) values (&#x27;丁经&#x27;);insert into person (name) values (&#x27;韦散&#x27;);insert into person (name) values (&#x27;东方让&#x27;);insert into person (name) values (&#x27;赖队瞻&#x27;);insert into person (name) values (&#x27;郭叹&#x27;);insert into person (name) values (&#x27;慕容芋岛&#x27;);insert into person (name) values (&#x27;孙劣&#x27;);insert into person (name) values (&#x27;王桃&#x27;);insert into person (name) values (&#x27;郝郑惭&#x27;);insert into person (name) values (&#x27;余烂&#x27;);insert into person (name) values (&#x27;宇文酚&#x27;);\n\n1select * from person;\n\n1select * from person partition(p0);\n\n1select * from person partition(p1);\n\n1select * from person partition(p2);\n\n1select * from person partition(p3);\n\nCOLUMNS 分区MySQL在5.5版本引入了COLUMNS分区类型，其中包括RANGE COLUMNS分区和LIST COLUMNS分区。以下是对这两种COLUMNS分区的详细说明：\n\nRANGE COLUMNS分区： RANGE COLUMNS分区是根据列的范围值将数据分布到不同的分区的分区策略。它类似于RANGE分区，但是根据多个列的范围值进行分区，而不是只根据一个列。这使得范围的定义更加灵活，可以基于多个列的组合来进行分区。下面是一个RANGE COLUMNS分区的代码示例：\n1234567891011create table product(    product_id int,    product_name varchar(50),    product_location int,    category_id int) partition by range columns(category_id,product_location)(    partition p11 values less than (1,1),    partition p12 values less than (1,2),    partition p21 values less than (2,1),    partition p22 values less than (2,2));\n\n每个分区根据这两列的范围值进行划分。\n\nLIST COLUMNS分区： LIST COLUMNS分区是根据列的离散值将数据分布到不同的分区的分区策略。它类似于LIST分区，但是根据多个列的离散值进行分区，而不是只根据一个列。这使得离散值的定义更加灵活，可以基于多个列的组合来进行分区。下面是一个LIST COLUMNS分区的代码示例：\n123456789create table product(    product_id int,    product_name varchar(50),    product_location int,    category_id int) partition by list columns(category_id,product_location)(    partition p12 values in ((1,1),(1,2)),    partition p22 values in ((2,1),(2,2)));\n\n常见分区命令向分区表添加新的分区1alter table sale add partition (partition p6 values less than (2026));\n\n删除指定的分区1alter table sale drop partition p6;\n\n重新组织分区12345alter table sale REORGANIZE PARTITION p0, p1, p2,p3, p4, p5 INTO (    partition p0 values less than (2021),    partition p1 values less than (2023),    partition p2 values less than (2025));\n\n合并相邻的分区1\n\n分析指定分区的统计信息1alter table sale analyze partition p0;\n\n主从复制\n服务器 openEuler\n\n一主一从\n\n\n角色\n主机名\nIP地址\n\n\n\n主库\nmaster\n192.168.1.201\n\n\n从库\nslave\n192.168.1.202\n\n\n分别安装MySQL下载MySQL1wget https://cdn.mysql.com//Downloads/MySQL-9.0/mysql-9.0.1-1.el9.x86_64.rpm-bundle.tar\n\n创建安装包目录1mkdir mysql\n\n释放安装包到安装包目录1tar -xvf mysql-9.0.1-1.el9.x86_64.rpm-bundle.tar -C mysql\n\n切换到MySQL安装包目录1cd mysql\n\n安装MySQL1rpm -ivh *.rpm  --force --nodeps\n\n启动MySQL1systemctl start mysqld\n\n设置MySQL开机自启动1systemctl enable mysqld\n\n在服务器初始启动时，假设服务器的数据目录为空，会发生以下情况：\n\n服务器已初始化。\n\nSSL 证书和密钥文件在数据目录中生成。\n\nvalidate_password 已安装并启用。\n\n创建了一个超级用户帐户&#39;root&#39;@&#39;localhost。超级用户的密码已设置并存储在错误日志文件中。要显示它，请使用以下命令：\n1grep &#x27;temporary password&#x27; /var/log/mysqld.log\n\n通过使用生成的临时密码登录并为超级用户帐户设置自定义密码，尽快更改 root 密码：\n1mysql -uroot -p\n\n修改密码12ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Lihaozhe!!@@1122&#x27;;FLUSH PRIVILEGES;\n\n设置远程访问地址12update mysql.user set host = &#x27;%&#x27; where user=&#x27;root&#x27;;FLUSH PRIVILEGES;\n\n退出MySQL1exit;\n\n重启MySQL1systemctl restart mysqld\n\n防火墙开放端口1firewall-cmd --zone=public --add-port=3306/tcp --add-port=33060/tcp --permanent\n\n重启防火墙1firewall-cmd --reload \n\n主库配置\n在主从库中分别建一个你需要同步的测试库，比如我这里创建的库叫lihaozhe，然后在这两个库中分别建一个测试表，都是空表即可。\n\n修改配置文件1vim /etc/my.cnf\n\n追加以下内容：\n\n实验配置\n\n1234server-id=201log-bin=mysql-bininnodb_flush_log_at_trx_commit = 1sync_binlog = 1\n\n\n生产环境配置\n还可以配置一些其他参数：\nlog_bin_index（bin日志文件索引位置），\nexpire_logs_days 日志多少天过期，binlog_format 等。\n\n1234server-id=201    #服务器 id，随意，但要唯一log-bin=mysql-bin   #二进制文件存放路径binlog-do-db=lihaozhe    #待同步的数据库日志binlog-ignore-db=mysql  #不同步的数据库日志\n\n创建账号用于主从复制1234#创建用户 我这里用户名为copyuser，注意这里的ip是从库服务器的ipCREATE USER &#x27;lihaozhe&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Lihaozhe!!@@6633&#x27;;#给主从复制账号授权grant replication slave on *.* to &#x27;lihaozhe&#x27;@&#x27;%&#x27;;\n\n重启MySQL1systemctl restart mysqld\n\n查看主库状态\n登录数据库后查看 \n\n1show master status;\n\n显示如下：\n12345678910mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      157 | lihaozhe     | mysql            |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)mysql&gt; \n\n\n注意：File 和 Position的值从库同步的时候需要\n\n从库配置\n在主从库中分别建一个你需要同步的测试库，比如我这里创建的库叫lihaozhe，然后在这两个库中分别建一个测试表，都是空表即可。\n\n修改配置文件1vim /etc/my.cnf\n\n追加以下内容：\n1234server-id=202    #服务器 id，随意，但要唯一log-bin=mysql-bin   #二进制文件存放路径replicate-do-db=lihaozhe    #待同步的数据库replicate-ignore-db=mysql,information_schema,performance_schema  #不同步的数据库\n\n\n以上面主库配置相比，就是除了server-id不一样，这里还需要配置replicate-do-db和replicate-ignore-db，注意不是日志。\n\n重启MySQL1systemctl restart mysqld\n\n实现主从同步\n登录数据库后\n\n1234567891011-- 关闭从库stop slave;-- 设置同步，注意这里是主库ip，日志名称和位置是我们之前上图中看到的名称和位置change master to master_host=&#x27;192.168.1.201&#x27;,master_user=&#x27;lihaozhe&#x27;,master_password=&#x27;Lihaozhe!!@@6633&#x27;,master_log_file=&#x27;mysql-bin.000001&#x27;,master_log_pos=157;-- 开启从库start slave; -- 检查服务器状态show slave status \\G;\n\n显示如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869mysql&gt; show slave status \\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for source to send event                  Master_Host: 192.168.1.201                  Master_User: lihaozhe                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 472               Relay_Log_File: slave-relay-bin.000002                Relay_Log_Pos: 326        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB: lihaozhe          Replicate_Ignore_DB: mysql,information_schema,performance_schema           Replicate_Do_Table:        Replicate_Ignore_Table:       Replicate_Wild_Do_Table:   Replicate_Wild_Ignore_Table:                    Last_Errno: 0                   Last_Error:                  Skip_Counter: 0          Exec_Master_Log_Pos: 472              Relay_Log_Space: 536              Until_Condition: None               Until_Log_File:                 Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:            Master_SSL_CA_Path:               Master_SSL_Cert:             Master_SSL_Cipher:                Master_SSL_Key:         Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:                Last_SQL_Errno: 0               Last_SQL_Error:   Replicate_Ignore_Server_Ids:              Master_Server_Id: 201                  Master_UUID: ee21ecf9-01be-11ed-916c-000c29c9a6f5             Master_Info_File: mysql.slave_master_info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Replica has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:       Last_IO_Error_Timestamp:      Last_SQL_Error_Timestamp:                Master_SSL_Crl:            Master_SSL_Crlpath:            Retrieved_Gtid_Set:             Executed_Gtid_Set:                 Auto_Position: 0         Replicate_Rewrite_DB:                  Channel_Name:            Master_TLS_Version:        Master_public_key_path:         Get_master_public_key: 0            Network_Namespace: 1 row in set, 1 warning (0.00 sec)ERROR: No query specifiedmysql&gt; \n\n测试\n主表操作，从表观察0\n\n","slug":"第一篇","date":"2024-10-16T01:28:20.128Z","categories_index":"","tags_index":"","author_index":"年阔正"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-10-16T01:24:11.687Z","categories_index":"","tags_index":"","author_index":"年阔正"}]